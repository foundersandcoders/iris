import { describe, it, expect } from 'vitest';
import { parseILR } from '../../../../src/lib/utils/xml/xmlParser';
import { generateILR } from '../../../../src/lib/utils/xml/xmlGenerator.legacy';
import type { ILRMessage } from '../../../../src/lib/utils/xml/xmlGenerator.legacy';
import * as fixtures from '../../../fixtures/lib/utils/xml/xmlParser';

describe('parseILR', () => {
	describe('valid XML', () => {
		it('parses valid minimal ILR XML', () => {
			const result = parseILR(fixtures.validMinimalXml);

			expect(result.success).toBe(true);
			if (!result.success) return;

			expect(result.data.header.collectionDetails.collection).toBe('ILR');
			expect(result.data.header.collectionDetails.year).toBe('2526');
			expect(result.data.header.source.ukprn).toBe(10000001);
			expect(result.data.learningProvider.ukprn).toBe(10000001);
			expect(result.data.learners).toHaveLength(1);
		});

		it('extracts learner fields correctly', () => {
			const result = parseILR(fixtures.validMinimalXml);

			expect(result.success).toBe(true);
			if (!result.success) return;

			const learner = result.data.learners[0];
			expect(learner.learnRefNumber).toBe('ABC123');
			expect(learner.uln).toBe(1234567890);
			expect(learner.familyName).toBe('Smith');
			expect(learner.givenNames).toBe('John');
			expect(learner.dateOfBirth).toBe('1995-03-15');
			expect(learner.ethnicity).toBe(31);
			expect(learner.sex).toBe('M');
			expect(learner.llddHealthProb).toBe(2);
			expect(learner.postcodePrior).toBe('E1 6AN');
			expect(learner.postcode).toBe('E2 8DP');
		});

		it('extracts learning delivery fields correctly', () => {
			const result = parseILR(fixtures.validMinimalXml);

			expect(result.success).toBe(true);
			if (!result.success) return;

			const delivery = result.data.learners[0].learningDeliveries[0];
			expect(delivery.learnAimRef).toBe('ZPROG001');
			expect(delivery.aimType).toBe(1);
			expect(delivery.aimSeqNumber).toBe(1);
			expect(delivery.learnStartDate).toBe('2025-09-01');
			expect(delivery.learnPlanEndDate).toBe('2026-08-31');
			expect(delivery.fundModel).toBe(36);
			expect(delivery.progType).toBe(25);
			expect(delivery.stdCode).toBe(123);
			expect(delivery.compStatus).toBe(1);
		});

		it('handles multiple learners', () => {
			const result = parseILR(fixtures.multipleLearnersXml);

			expect(result.success).toBe(true);
			if (!result.success) return;

			expect(result.data.learners).toHaveLength(2);
			expect(result.data.learners[0].learnRefNumber).toBe('L001');
			expect(result.data.learners[1].learnRefNumber).toBe('L002');
		});
	});

	describe('invalid XML', () => {
		it('returns error for malformed XML', () => {
			const result = parseILR(fixtures.malformedXml);

			expect(result.success).toBe(false);
			if (result.success) return;

			expect(result.error.code).toBe('INVALID_XML');
		});

		it('returns error for missing Message element', () => {
			const result = parseILR(fixtures.missingMessageXml);

			expect(result.success).toBe(false);
			if (result.success) return;

			expect(result.error.code).toBe('MISSING_ELEMENT');
			expect(result.error.message).toContain('Message');
		});

		it('parses XML with missing required learner fields (uses NaN for missing numerics)', () => {
			const result = parseILR(fixtures.missingRequiredFieldsXml);

			expect(result.success).toBe(true);
			if (!result.success) return;

			// Verify the parser succeeded and used NaN for missing numeric field
			expect(result.data.learners).toHaveLength(1);
			expect(Number.isNaN(result.data.learners[0].uln)).toBe(true);
		});
	});

	describe('round-trip', () => {
		it('parses XML generated by generateILR', () => {
			const original = fixtures.roundTripMessage;

			const xml = generateILR(original);
			const result = parseILR(xml);

			expect(result.success).toBe(true);
			if (!result.success) return;

			expect(result.data.header.collectionDetails.year).toBe(
				original.header.collectionDetails.year
			);
			expect(result.data.learningProvider.ukprn).toBe(original.learningProvider.ukprn);
			expect(result.data.learners[0].learnRefNumber).toBe(original.learners[0].learnRefNumber);
			expect(result.data.learners[0].uln).toBe(original.learners[0].uln);
			expect(result.data.learners[0].learningDeliveries[0].learnAimRef).toBe(
				original.learners[0].learningDeliveries[0].learnAimRef
			);
		});
	});
});
